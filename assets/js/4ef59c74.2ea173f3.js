"use strict";(self.webpackChunkreact_bearer_auth_context=self.webpackChunkreact_bearer_auth_context||[]).push([[159],{2865:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return k}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),s=["components"],i={id:"network-calls",custom_edit_url:null,sidebar_label:"Making Network Calls",slug:"/network-calls"},l="Making Network Calls",c={unversionedId:"network-calls",id:"network-calls",isDocsHomePage:!1,title:"Making Network Calls",description:"Bearer Auth React Context performs token refresh lazily. Rather than keeping track of time",source:"@site/docs/network-calls.mdx",sourceDirName:".",slug:"/network-calls",permalink:"/bearer-auth-react-context/network-calls",editUrl:null,tags:[],version:"current",frontMatter:{id:"network-calls",custom_edit_url:null,sidebar_label:"Making Network Calls",slug:"/network-calls"},sidebar:"sidebar",previous:{title:"Handling Refresh",permalink:"/bearer-auth-react-context/handling-refresh"},next:{title:"API Reference",permalink:"/bearer-auth-react-context/api-reference/"}},u=[],p={toc:u};function k(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"making-network-calls"},"Making Network Calls"),(0,o.kt)("p",null,"Bearer Auth React Context performs token refresh lazily. Rather than keeping track of time\n(and refreshing the token just as it's about to expire), it monitors network requests.\nSince this library is not tied to any specific network library, it's unable to use interceptors to monitor the requests.\nIf a request fails, user-provided ",(0,o.kt)("inlineCode",{parentName:"p"},"hasTokenExpired()")," function is called to check if request failed because of outdated token."),(0,o.kt)("p",null,'All request functions (or, as they\'re called internally, "fetchers") need to fulfil a specific interface:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"type Fetcher<FetcherConfig extends Tokens, Data, Args> = (\n  config: FetcherConfig\n) => (args: Args) => Promise<Data>;\n")),(0,o.kt)("p",null,"For example, using ",(0,o.kt)("inlineCode",{parentName:"p"},"fetch"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export const getPets = (config: FetchConfig) => (): Promise<Pet> => {\n  const { baseUrl, bearerToken } = config;\n  const url = baseUrl + '/pets';\n  return new Promise<Pet>(async (resolve, reject) => {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: buildHeaders(bearerToken),\n      });\n      const json = await response.json();\n      if (!response.ok) {\n        reject({ response, body: json });\n      }\n      resolve(json);\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n")),(0,o.kt)("p",null,"If you're using OpenAPI, you can use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/frysztak/openapi-generator"},"this generator")," to automatically produce request functions."),(0,o.kt)("p",null,"Each call requires ",(0,o.kt)("inlineCode",{parentName:"p"},"config")," (which includes ",(0,o.kt)("inlineCode",{parentName:"p"},"bearerToken"),"), which is stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"BearerAuthContextProvider"),".\nAccessing it manually each time would be inconvenient, but thanks to curried form of the fetcher function,\nit's trivial to implement a tiny wrapper. It's available as ",(0,o.kt)("inlineCode",{parentName:"p"},"useBearerAuthWrapper()")," hook.\nExample usage (with React-Query):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const petsQuery = useQuery('pets', useBearerAuthWrapper(getPets));\n// do whatever with `petsQuery`\n")))}k.isMDXComponent=!0}}]);